#!/usr/bin/env python3
"""
Verify polygon closure in vector tiles generated by tippecanoe.
This script checks if water polygons are properly closed in the generated tiles.
"""

import json
import subprocess
import sys
import os
from pathlib import Path

def check_pmtiles_content(pmtiles_path):
    """
    Extract and examine the content of a PMTiles file to check polygon closure.
    Uses tile-join or pmtiles commands to inspect the content.
    """
    try:
        # First, let's try to get basic info about the PMTiles file
        cmd = ["pmtiles", "show", pmtiles_path]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"PMTiles info for {pmtiles_path}:")
            print(result.stdout)
            return True
        else:
            print(f"Error getting PMTiles info: {result.stderr}")
            return False
            
    except FileNotFoundError:
        print("pmtiles command not found. Trying alternative approach...")
        return check_with_tippecanoe(pmtiles_path)

def check_with_tippecanoe(pmtiles_path):
    """
    Try to extract sample data using tippecanoe tools.
    """
    try:
        # Extract a sample tile to examine geometry
        output_dir = Path(pmtiles_path).parent / "temp_extract"
        output_dir.mkdir(exist_ok=True)
        
        # Use tile-join to extract a sample
        cmd = ["tile-join", "-e", str(output_dir), pmtiles_path, "-z", "10"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"Successfully extracted sample tiles to {output_dir}")
            # Look for a sample tile
            for tile_file in output_dir.glob("**/*.pbf"):
                print(f"Found sample tile: {tile_file}")
                return True
        else:
            print(f"Error extracting tiles: {result.stderr}")
            return False
            
    except FileNotFoundError:
        print("tile-join command not found. Please install tippecanoe tools.")
        return False

def check_geojson_polygons(geojson_path):
    """
    Check if polygons in the source GeoJSON data are properly closed.
    """
    print(f"\nChecking source data: {geojson_path}")
    
    if not os.path.exists(geojson_path):
        print(f"Source file not found: {geojson_path}")
        return False
    
    unclosed_count = 0
    total_polygons = 0
    
    try:
        with open(geojson_path, 'r') as f:
            for line_num, line in enumerate(f, 1):
                if line.strip():
                    try:
                        feature = json.loads(line)
                        if feature.get('type') == 'Feature':
                            geometry = feature.get('geometry', {})
                            if geometry.get('type') in ['Polygon', 'MultiPolygon']:
                                total_polygons += 1
                                if not is_polygon_closed(geometry):
                                    unclosed_count += 1
                                    print(f"Line {line_num}: Unclosed polygon found")
                    except json.JSONDecodeError as e:
                        print(f"Line {line_num}: JSON decode error - {e}")
                        
    except Exception as e:
        print(f"Error reading file: {e}")
        return False
    
    print(f"Total polygons checked: {total_polygons}")
    print(f"Unclosed polygons found: {unclosed_count}")
    
    return unclosed_count == 0

def is_polygon_closed(geometry):
    """
    Check if a polygon geometry has properly closed rings.
    """
    if geometry['type'] == 'Polygon':
        coordinates = geometry['coordinates']
        for ring in coordinates:
            if len(ring) < 4:  # Minimum for a closed polygon
                return False
            if ring[0] != ring[-1]:  # First and last point should be the same
                return False
    elif geometry['type'] == 'MultiPolygon':
        coordinates = geometry['coordinates']
        for polygon in coordinates:
            for ring in polygon:
                if len(ring) < 4:
                    return False
                if ring[0] != ring[-1]:
                    return False
    
    return True

def main():
    """
    Main function to verify polygon closure in vector tiles.
    """
    script_dir = Path(__file__).parent
    
    # Check the water tiles
    water_tiles = script_dir / "tiles" / "st_lawrence_water.pmtiles"
    water_source = script_dir / "data" / "st_lawrence_water.geojsonseq"
    
    print("=== Vector Tile Polygon Closure Verification ===\n")
    
    # First check the source data
    print("1. Checking source GeoJSON data...")
    source_ok = check_geojson_polygons(water_source)
    
    # Then check the generated tiles
    print("\n2. Checking generated PMTiles...")
    if water_tiles.exists():
        tiles_ok = check_pmtiles_content(water_tiles)
        
        if tiles_ok:
            print("\n✓ Water tiles generated successfully")
        else:
            print("\n✗ Issues found with water tiles")
    else:
        print(f"✗ Water tiles not found: {water_tiles}")
    
    # Summary
    print("\n=== Summary ===")
    if source_ok:
        print("✓ Source data polygons are properly closed")
    else:
        print("✗ Source data contains unclosed polygons")
    
    print("\nTo further verify the tiles visually:")
    print("1. Use a tool like QGIS to load the PMTiles file")
    print("2. Check for any 'hanging' vertices or unclosed polygons")
    print("3. Look for any geometry errors in the water layer")
    
    # Provide tippecanoe command used
    print(f"\nTiles were generated using tippecanoe with these settings:")
    print("- --force to overwrite existing tiles")
    print("- --no-simplification-of-shared-nodes to preserve topology")
    print("- --no-tiny-polygon-reduction to keep small polygons")
    print("- --preserve-input-order to maintain feature order")
    print("- Appropriate zoom levels for the data")

if __name__ == "__main__":
    main()
